// Copyright 2020-2022 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

//! A Verifiable Presentation (VP) represents a bundle of one or more Verifiable Credentials.
//! This example demonstrates building and usage of VPs.
//!
//! cargo run --example account_create_vp

use identity_iota::account::Account;
use identity_iota::account::AccountBuilder;
use identity_iota::account::IdentitySetup;
use identity_iota::account::MethodContent;
use identity_iota::core::json;
use identity_iota::core::Duration;
use identity_iota::core::FromJson;
use identity_iota::core::Timestamp;
use identity_iota::core::ToJson;
use identity_iota::core::Url;
use identity_iota::credential::Credential;
use identity_iota::credential::CredentialBuilder;
use identity_iota::credential::Presentation;
use identity_iota::credential::PresentationBuilder;
use identity_iota::credential::Subject;
use identity_iota::crypto::ProofOptions;
use identity_iota::did::verifiable::VerifierOptions;

use identity_iota::account::Result;
use identity_iota::client::CredentialValidationOptions;
use identity_iota::client::FailFast;
use identity_iota::client::PresentationValidationOptions;

use identity_iota::client::Resolver;
use identity_iota::client::SubjectHolderRelationship;

#[tokio::main]
async fn main() -> Result<()> {
    // ===========================================================================
    // Step 1: Create identities for the issuer and the holder.
    // ===========================================================================

    // Create an account builder with in-memory storage for simplicity.
    // See `create_did` example to configure Stronghold storage.
    let mut builder: AccountBuilder = Account::builder();

    // Create an identity for the issuer.
    let mut issuer: Account = builder.create_identity(IdentitySetup::default()).await?;

    // Add a dedicated verification method to the issuer, with which to sign credentials.
    issuer
        .update_identity()
        .create_method()
        .content(MethodContent::GenerateEd25519)
        .fragment("issuerKey")
        .apply()
        .await?;

    // Create an identity for the holder, in this case also the subject.
    let mut alice: Account = builder.create_identity(IdentitySetup::default()).await?;

    // Add verification method to the holder.
    alice
        .update_identity()
        .create_method()
        .content(MethodContent::GenerateEd25519)
        .fragment("aliceKey")
        .apply()
        .await?;

    // ===========================================================================
    // Step 2: Issuer creates and signs a Verifiable Credential.
    // ===========================================================================

    // Create VC "subject" field containing subject ID and claims about it.
    let subject: Subject = Subject::from_json_value(json!({
      "id": alice.did().to_string(),
      "name": "Alice",
      "degree": {
        "type": "BachelorDegree",
        "name": "Bachelor of Science and Arts",
      },
      "GPA": "4.0",
    }))?;

    // Build credential using subject above and issuer.
    let mut credential: Credential = CredentialBuilder::default()
        .id(Url::parse("https://example.edu/credentials/3732")?)
        .issuer(Url::parse(issuer.did().to_string())?)
        .type_("UniversityDegreeCredential")
        .subject(subject)
        .build()?;

    // Sign the Credential with the issuers default key.
    issuer
        .sign("#issuerKey", &mut credential, ProofOptions::default())
        .await?;

    println!("Credential JSON > {:#}", credential);

    // ===========================================================================
    // Step 3: Issuer sends the Verifiable Credential to the holder.
    // ===========================================================================

    // The credential is then serialized to JSON and transmitted to the holder in a secure manner.
    // Note that the credential is NOT published to the IOTA Tangle. It is sent and stored off-chain.
    let credential_json: String = credential.to_json()?;

    // ===========================================================================
    // Step 4: Verifier sends the holder a challenge and requests a signed Verifiable Presentation.
    // ===========================================================================

    // A unique random challenge generated by the requester per presentation can mitigate replay attacks
    let challenge: &str = "475a7984-1bb5-4c4c-a56f-822bccd46440";

    // The verifier and holder also agree that the signature should have an expiry date
    // 10 minutes from now.
    let expires: Timestamp = Timestamp::now_utc()
        .checked_add(Duration::minutes(10))
        .unwrap();

    // ===========================================================================
    // Step 5: Holder creates and signs a verifiable presentation from the issued credential.
    // ===========================================================================

    // Deserialize the credential.
    let credential: Credential = Credential::from_json(credential_json.as_str())?;

    // Create an unsigned Presentation from the previously issued Verifiable Credential.
    let mut presentation: Presentation = PresentationBuilder::default()
        .holder(Url::parse(alice.did().as_ref())?)
        .credential(credential)
        .build()?;

    // Sign the verifiable presentation using the holder's verification method
    // and include the requested challenge and expiry timestamp.
    alice
        .sign(
            "#aliceKey",
            &mut presentation,
            ProofOptions::new()
                .challenge(challenge.to_string())
                .expires(expires),
        )
        .await?;

    // ===========================================================================
    // Step 6: Holder sends a verifiable presentation to the verifier.
    // ===========================================================================

    // Convert the Verifiable Presentation to JSON to send it to the verifier.
    let presentation_json: String = presentation.to_json()?;

    // ===========================================================================
    // Step 7: Verifier receives the Verifiable Presentation and verifies it.
    // ===========================================================================

    // Deserialize the presentation from the holder:
    let presentation: Presentation = Presentation::from_json(&presentation_json)?;

    // The verifier wants the following requirements to be satisfied:
    // - Signature verification (including checking the requested challenge to mitigate replay attacks)
    // - Presentation validation must fail if credentials expiring within the next 10 hours are encountered
    // - The presentation holder must always be the subject, regardless of the presence of the nonTransferable property
    // - The issuance date must not be in the future.

    let presentation_verifier_options: VerifierOptions = VerifierOptions::new()
        .challenge(challenge.to_owned())
        .allow_expired(false);

    // Do not allow credentials that expire within the next 10 hours.
    let credential_validation_options: CredentialValidationOptions =
        CredentialValidationOptions::default().earliest_expiry_date(
            Timestamp::now_utc()
                .checked_add(Duration::hours(10))
                .unwrap(),
        );

    let presentation_validation_options = PresentationValidationOptions::default()
        .presentation_verifier_options(presentation_verifier_options.clone())
        .shared_validation_options(credential_validation_options)
        .subject_holder_relationship(SubjectHolderRelationship::AlwaysSubject);

    // Validate the presentation and all the credentials included in it.
    let resolver: Resolver = Resolver::new().await?;
    resolver
        .verify_presentation(
            &presentation,
            &presentation_validation_options,
            FailFast::FirstError,
            None,
            None,
        )
        .await?;

    // Since no errors were thrown by `verify_presentation` we know that the validation was successful.
    println!("VP successfully validated");

    // Note that we did not declare a latest allowed issuance date for credentials. This is because we only want to check
    // that the credentials do not have an issuance date in the future which is a default check.

    Ok(())
}
